### Observables and Subscribers
Фундаментальная идея в основе реактивного программирования: события - это данные, данные - это события.

#### `Observable`
 
- `onNext()` - передаёт каждый элемент вниз до `Observer`.
- `onComplete()` - свидетельствует о том, что нет больше никаких `onNext()`.
- `onError()` - отправляет ошибку вниз по цепочке вплоть до самого `Observer`, где ,как правило, определена обработка ошибок. Если не использован оператор `retry()` или один из методов вида `onErrorResumeNext()` (https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators), то по контракту больше никаких элементов не заэмитится.
 
`Observable.create()` -  фабрика, позволяющая создать `Observable` и обозначить эмиттер. Нужна для хуков вокруг нереактивных источников данных/событий. В первой rxJava это был `Observable.fromEmitter()`. Стоит обратить внимание, что `Observable` может эмитить один элемент за период времени. `map()` и `filter()` возвращают новый `Observable`.

Во второй rxJav'e нельзя эмиттить Null.

#### Интерфейс `Observer`
Методы `onNext()`, `onComplete()`, `onError()` определяют тип обзёрвера. В первой эрыксджаве это был `Subscriber`. Во второй `Subscriber` появляется только когда речь идёт о `Flowables`. Если при выпуске элементов в `Observable` произойдёт ошибка, то она упадёт в `Observer.onError()`.
    
#### Функции в rxJava (аналогично Java8)

Имя | single-abstract-method | Описание
--------|---------|-----------
`Action` | `run()` | Запускает операцию, похоже на `Runnable`
`Callable<T>`	| `get()` | Возвращает элемент типа `T`
`Consumer<T>` | `accept()` | Что-то делает над `T`, ничего не возвращает
`Function<T,R>` | `apply()` | Принимает `T`, возвращает `R`
`Predicate<T>` | `test()` | Принимает `Т`, возвращает `boolean`
`BiConsumer<T1,T2>` | `accept()` | см.`Consumer<T>`
`BiFunction<T1,T2,R>` | `apply()` | Принимает `T1`, `T2`, возвращает `R`
`BiPredicate<T1,T2>`	| `test()` | см.`Predicate<T>`
`Function3<T1,T2,T3,R>` | `apply()` | Принимает три аргумента, возвращает `R`
`BooleanSupplier` | `getAsBoolean()` | Возвращает булю
`LongConsumer` | `accept()` | Что-то делает с входным лонгом и всё
`IntFunction` | `apply()` |	Принимает `int` и возвращает `T`	
			
#### Cold vs Hot
Обсерваблы, которые эмитят конечные данные чаще всего _cold_ (отрабатывают тогда, когда на них подписались). Горячие похожи на _broadcast_, вещают всем подписчикам.
Работает, как радио. Если пропустил трэк, его уже не услышишь. Горячие чаще всего отображают события, нежели какие-то данные.

`ConnectableObservable` - полезная форма горячего обзёрвабла. Он берёт любой Observable и делает из него _hot_, чтобы он эмитил всем подписчикам одновременно.
Просто вызови `publish()` у любого обзёрвабла и он вернёт `ConnectableObservable`.
Но subscribe на такой обзёрвабл не вызовет эмиты. У него надо вызвать `connect()`, чтобы тот начал пулять. То есть можно подписать несколько на `ConnectableObservable`, потом ткнуть `source.connect()`, и только тогда все подписчики получат свои данные. Такая фиговина более известна, как _Multicasting_.

#### Другие фабрики для создания Observable
- `Observable.range()` - для создания последовательности интов. Создаётся до тех пор, пока не будет достигнут конечный инт. Все инты передаются через `onNext()`, что неудивительно.

- `Observable.interval()` - _time-based_ обзёрвабл, который эмитит с заданным
интервалом. Бесконечный. _Cold_.

- `Observable.future()` - хер его знает, не особо-то описано. Обёртка над `Future`.

- `Observable.empty()` - ничего не эмитит и вызвает `onComplete()`. Вместо *null*'ов.

- `Observable.never()` - похож на `empty()`, только никогда не вызывает `onComplete()`.

- `Observable.error()` - вызывает `onError()`.

- `Observable.defer()` - какая-то мощная фиговина, так как может создавать _separate state_(отдельное состояние) для каждого `Observable`. Ну например нам нужно подтягивать изменившееся состояние в обзёрвабл.

- `Observable.fromCallable()` - если нам надо произвести какое-то вычисление или операцию, а затем заэмитить его/её, можно просто вызвать `Observable.just()`.
Но иногда надо это проделать лениво. Также, если эта операция вызывает ошибку, лучше бы она её выкидывала только на момент выполнения чейна.
Более того, если в `Observable.just()` ёбнет ошибка, то она не будет передана в `Observer`. Короче говоря, если то, что вы оборачиваете в `Observable` может вызывать ошибку, то оборачивать надо в `Observable.fromCallable()`.

#### Single, Completable, Maybe
Есть три разных типа обзёрваблов, которые эмитят ноль или один элемент.

- `Single` - эмитит, вот это поворот, один элемент. `onSuccess()` включает в себя `onNext()` и `onComplete()`. В лямбде, соответственно, ловится `onSuccess()` и `onError()`.

- `Maybe` - если количество элементов от 0 до 1.

- `Completable` - придуман для того, чтобы выполнять какое-то действие. Ничего не получает. Есть `onError()` и `onComplete()`.

#### Disposing
Когда мы вызываем `subscribe()`, создаётся поток и обрабатывает emissions в цепочке. Для этого выделяются какие-то ресурсы. Слава Богу, `Observable` высвобождает эти ресурсы как только отрабатывает `onComplete()`. Но в случае, если у нас бесконечный или турбо долгий поток, нам может понадобится конкретный `dispose`.
Короче, нельзя доверять **GC** чистку толстых потоков, надо диспозить самому, чтобы избежать мемори ликов.
`Disposable` - это связующее звено между `Observable` и активным `Observer`. Можно вызывать его `dispose()` для того, чтобы прекратить эмитить элементы и высвободить все ресурсы, затраченные на их выпуск.

##### Disposable в обзёрвере
В `onSubscribe(Disposable d)` у обзёрвера передан `Disposable`. Это нужно для того, чтобы обзёрвер мог контролировать подписку и у него был вариант отписаться в любой момент. `Disposable` передаётся по всей цепочке обзёрваблов. Вообще, передача `Observer`'a в `subscribe()` не вернёт `Disposable` (rxJava сама захэндлит это вот всё), но если очень надо, то можно юзануть `subscribeWith(Disposable)`, тем самым получив дефолтный `Disposable`.

Использование `CompositeDisposable`. НужнО в случае, если у нас несколько подписок, а мы хотим манагить их (отписаться от всех разом, к примеру).

-----

### Basic Operators
Тут важно вкурить, что операторы сами являются `Observer`'ом для своего `Observable` выше по цепочке.

#### Suppressing operators
Эти операторы просто тупо не вызывают onNext(), если не проходит какое-то условие. Соответственно, элемент не проходит вниз по цепочке.

- `filter()` - принимает `Predicate<T>` для обзёрвабла `T`. Каждый эмишн мапится в булю, которая говорит - подходит данный эмишн к условию или нет. Эмишены `False` дальше не проходят. Если вообще нет подходящих вариантов, то вернётся пустой `Observable`, ферштейн?

- `take()` - у него несколько реализаций, тривиально.

- `skip()` - противоположно `take()`.

- `takeWhile()`, `skipWhile()` - принимает/пропускает, пока соответствует условию.

- `takeUntil()`, `skipUntil()` - принимают другой `Observable` в качестве параметра. Принимают/пропускают, пока другой обзёрвабл продолжает эмитить.

- `distinct()` - будет эмитить каждый уникальный элемент, но подавлять повторяющиеся. Сравнение работает на `hashcode()`/`equals()` выпускаемых объектов. Надо иметь в виду, что если если у нас дохрена уникальных элементов, то этот оператор будет есть память. Типа как если бы каждая подписка создавала `HashSet`, отслеживающий предыдущие выпущенные элементы. Можно также кинуть в `distinct()` лямбду, по которой будет отобран уникальный ключ.

- `distinctUntilChanged()` - полезная штуковина. Эмитит элементы, если входящие значения изменились. То есть она игнорит последовательно повторяющиеся элементы.
`2,2,3,3,3,1,1 -> 2,3,1`. Также принимает лямбду на вход, по которой собственно сравнивает элементы.
>В Tanderstore можно применять "новые" полученные политики только
если они изменились - круто же.

- `elementAt()` - можно получить специфичный эмишн по его id'шнику (`long` от 0 до `Long.MAX_VALUE`). Возвращает `Maybe<T>`. У него есть разные реализации:
	- `elementAtOrError()` -  вернёт `Single` или `Error` (в случае, если по данному индексу нифига нет).
	- `singleElement()` - вернёт Observable, обёрнутый в Maybe
	- `firstElement()` и `lastElement()`.

#### Transforming operators
- `map()` - для заданного `Observable<T>` меняет `T` на `R`, используя функцию `Function<T,R>`.
Конвертирует один-к-одному каждый эмишн. Если нужно конвертить один-к-нескольким эмишнов, то надо использовать `flatMap()` или `concatMap()`.

- `cast()` - _map-like_ оператор, который кастует каждый эмишн к заданному типу. Некий такой брут-форс для приведения типов. Лучше правильно юзать дженерики, разумеется.

- `startWith()` - позволяет нам впихнуть какой-нибудь эмишн, с которого начинаются другие эмишны.
Например, у нас есть `Observable<String>`,выпускающий элементы, которые мы хотим напечатать в менюшке. Можно использовать `startWith()`, чтобы сначала написать заголовок менюшки.
```
Observable.just("Чай", "Кофе", "Лимонад")
	.startWith("НАПИТКИ")
	.subscribe(System.out::println)
	
>output: 
		НАПИТКИ 
		Чай
		Кофе
		Лимонад
```
Если нам нужно больше, чем один элемент для старта, можно бахнуть

- `startWithArray()`, тогда отработают сначала элементы массива. Если нужно ждать выпуск всех эмишнов другого `Obsaervable`, стоит использовать `Observable.concat()` или `concatWith()`.

- `defaultIfEmpty()` - подставляет дефолт, если пусто. Вот это да.

- `switchIfEmpty()` - переключается на другой `Observable`, если предыдущий не заэмитил ни одного элемента.

- `sorted()` - если у нас есть конечный `Observable<T>`, который выпускает элементы `Comparable<T>`, можно юзать этот оператор, чтобы сортировать эмишены. Под капотом он соберёт все эмишены, а потом перевыпустит их в заданном порядке. Если применить к бесконечному `Observable`, получим `OutOfMemory`, естесна. Можно подать `Comparator` в качестве аргумента.

- `delay()` - собирает все элементы и выпускает затем один за одним с заданным интервалом. Так как оперирует на другом шедулере, то надо это иметь в виду и не тупить в посках выполненной операции. Она могла не успеть выполниться до завершения _main_-потока. Для применения продвинутого `delay()` можно подать в него другой `Observable`, и этот дилей отложит свои эмишены на время, пока данный обзёрвабл чё-нить не выпустит. Есть также такая штука, как `delaySubscription()`, которая откладывает подписку, а не выпуск эмишнов.

- `repeat()` - повторит подписку после `onComplete()` заданное количество раз. Есть ещё `repeatUntil()`, который принимает `BooleanSupplier` и продолжает повторения до тех пор, пока супплаер не выдаст `true`.

- `scan()` - _rolling_ аггрегатор. Аккумулирует каждый эмишн и добавляет его к следующему.
```java
Observable.just(5, 3, 7, 10)
	.scan((accumulator, next) -> accumulator + next)
	.subscribe(System.out::println)

>output: 5 8 15 25
```
Это не обязательно лепить для интеджеров, можно аккумулировать всё что угодно. Отличается от `reduce()` тем, что тот берёт один эмишн, когда отрабатывает `onComplete()`. Может использоваться в бесконечных обзёрваблах.

#### Reducing operators
Будут случаи, когда необходимо взять серии эмишенов и сконсолидировать их в один элемент (зачастую какой-нибудь `Single`). Для этого есть несколько операторов. Заметьте, что ==эти операторы работают только с конечным `Observable`, который вызывает `onComplete()`==.

- `count()` - простейший оператор для объединения множества эмишенов. Он подсчитает количество элементов и выпустит `Single`, когда отработает `onComplete()`. Если нужно посчитать эмишены на бесконечном обзёрвабле, юзать `scan()`.

- `reduce()` - синтаксически похож на `scan()`, но только выдаёт последнее саккумулированное значение. Может выдать `Single` или `Maybe` в зависимости от вашей имплементации. Например, если нужон общий интеджер:
```java
Observable.just(5, 3, 7, 10, 2, 14)
	.reduce((total, next) -> total + next)
	.subscribe(System.out::println)

>output: 41
```

- `all()` - эта хреновена проверяет, что все элементы подпадают под определённый критерий и возвращает `Single<Boolean>`. Как только один из элементов не совпадает, ==сразу== возвращает `False`.
>Не тупи и запомни: если вызвать `all()` к пустому обзёрваблу, он выдаст `True`.

- `any()` - соответственно, если есть хотя бы один подходящий эмишн. 
>Кстати, если вызвать его у пустого обзёрвабла, то он выдаст `False`.

- `contains()` - тут всё просто: вырнёт булю, если в эмишеннах есть данный элемент. Работает на `hashCode()`/`equals()`.

#### Collection operators
Аккумулируют все эмишены и собирают в одну коллекцию, типа листа или мапы. Затем выплёвывают эту коллекцию. Являются на самом деле ещё одной формой  _reducing operators_, но достойны отдельного параграфа. Кстати да, не стоит злоупотреблять этими операторами, так как это может навредить вашей реактивщине: лучше обрабатывать ивенты один-за-другим, так же, как они эмитятся, нежели скидывать всё в кучу и потом разгребать её. Смысл эрыкса тогда?

- `toList()` - собирает все эмишены из `Observable<T>` в `List<T>` и выдаёт его в виде `Single<List<T>>`. После того, как `Observable` отстреливает `onComplete()`, лист пушится в обзёрвер. По дефолту, этот лист будет `ArrayList`'ом, можно передать _capacity_ и задать таким образом ограничение на количество элементов.

- `toSortedList()` - собирает в сортированный лист (работает на `Comparator`'ах). Соответственно, можно передать компаратор в качестве аргумента.

- `toMap()` - для заданного `Observable<T>` соберёт в `Map<K,T>`, где `K` - ключ, полученный из лямбды `Function<T,K>`.
```java
Observable.just("Раз", "Два", "Три")
	.toMap(s -> s.charAt(0))
	.subscribe(System.out::println)

>output: {Р=Раз, Д=Два, Т=Три}
```
Можно и посложнее смаппить, если в лямбду передать через запятую правило для `value`.
```java
... 
	.toMap(s-> s.charAt(0), String::length)
	.subscribe(..)

>output: {Р=3, Д=3, Т=3}
```
По дефолту `toMap()` использует `HashMap`, можно обеспечить `ConcurrentHashMap`: `.toMap(s-> s.charAt(0), String::length, ConcurrentHashMap::new)`.

- `toMultiMap()` поддерживает случаи, когда хэши совпадают. Значения в таком случае складываются в список.

- `collect()` - нужен, чтобы собрать элементы в специфическую коллекцию:
`.collect(HashSet::new, HashSet::add)` соберёт в `HashSet` и выдаст `Single<HashSet>`. Используйте `collect()` вместо `reduce()`, когда вы собираете эмишены в мутабельный объект, чтобы затем получить _sealed_ объект.
Хороший пример с **guava**:
```java
Observable.just("Оп", "Оп", "Опана")
// собрали в билдер все элементы
	.collect(ImmutableList::builder, ImmutableList::add)
// сбилдили неизменяемый гуавовский список
	.map(ImmutableList.Builder::build)
	.subscribe(..)
```
В общем `collect()` хорош для сбора элементов в любую "нестандартную"
для rxjava коллекцию.
        
#### Error recovery operators
Так, ну мы уже знаем про метод `onError()`, который пронизывает всю цепочку от `Observable` до `Observer`. После его срабатываения, поток завершает выполнение и никаких эмишенов больше не происходит. Но иногда нам надо перехватить ошибку _до_ того, как она провалится до `Observer`'a и поток завершится с ошибкой.

- `onErrorReturn()` и `onErrorReturnItem()` - когда нужно вернуть дефолтный элемент в случае ошибки. Принимает лямбду с `Throwable`'ом. Важно, где стоит в цепочке. Чтобы ловить ошибку, должен стоять после обзёрвабла, который выдал эту ошибку (логично, потому как каждый следующий член цепочки является `Observer`'ом предыдущего члена и `Observabl`'ом для следущего).

- `onErrorResumeNext()` - аналогичен предыдущим, только принимает ещё другой `Observable` в качестве параметра (который эмитится на случай ошибки). Можно по красоте бахнуть например `.onErrorResumeNext(Observable.empty())` и вызвать тем самым `onComplete()` в цепочке, где произошла ошибка. Искать только её потом устанем (прим.автора).

- `retry()` - переподписывается к `Observabl`'у в надежде, что ошибка рассосётся сама по себе. Есть несколько перегруженных методов. Можно, например, задать интом количество попыток. Можно пульнуть в него `Predicate<Throwable>` или `BiPredicate<Integer,Throwable>`, чтобы более точно описать случай, когда должен отработать `retry()`. `retryUntil()` будет пересабскрайбиться до тех пор, пока соотв. `BooleanSupplier` в лямбде выдаёт `false`. Есть также крутой `retryWhen()`. С его помощью можно применить композицию из задач для ретрая (к примеру, выставить `delay` для `retry`).

#### Action operators
Помогают при дебаге, улучшают понимание того, что собственно проиходит в чейне. Вставлять между целевым обзёрвером и его обзёрваблом (прим.автора).
	
- `doOnNext()` - позволяет брать эмишены предыдущего `Observable`'а. Что-то типа мини-обзёрвабла в середине цепочки. Он никак не меняет эмишены. С помощью `doOnNext()` мы просто создаём _side-effect_ для каждого ивента в цепочке. В этом примере мы просто выведем все стринги в консоль до того, как они упадут в оператор `map()`:
```java
Observable.just("One", "Four", "Twelve")
	.doOnNext(s -> System.out::println)
	.map(String::length)
	.subscribe(System.out::println)

>output: One 3 Four 4 Twelve 6
```
Есть также `doAfterNext()`, который предпринимет заданное действие _ПОСЛЕ_
того, как эмишн ушёл дальше по цепочке.

- `doOnComplete()` - срабатывает, когда чейн вызывает свой `onComplete()`. Может быть полезен в случае, когда нужно понять, какая часть цепочки отработала нормально и завершилась `onComplete()`. 
		
- `doOnError()` - соответственно, срабатывает, когда по цепочке пробрасывается ошибка. Опять же, полезно вставлять между операторами. Тут лучше с примером:
```java
Observable.just(5, 2, 4, 0, 3, 2, 8)
	.doOnError(e -> System.out.println("Source failed")
	.map(i -> 10/i)
	.doOnError(e -> System.out.prinln("Division failed!")
	.subscribe(i -> System.out::println,
				e -> System.out.println("Observer gets error");

> output: 2 5 2 Division failed! Observer gets error
```
То есть "Source failed" не отработал, так как не было выпущено никаких ошибок из `.just(...)`.
Есть также `doOnEach()`, где мы можем определить действие для всех трёх предыдущих операторов. Это типа как влепить `subscribe()` посередине чейна.
		
- `doOnSubscribe()` - выпускает `Consumer<Disposable>` в момент, когда в чейне срабатывает подписка. Предоставляет доступ к `Disposable` на случай, если нам нужно вызвать `dispose()`.

- `doOnDispose()` - позволяет предпринять какую-то операцию в момент, когда в чейне отработал `dispose()`. 
>Если нам нужно сделать что-то в любом случае, будь то `onComplete()`, `onError()` или `dispose`, нам понадобится `doFinally()`, который отрабатывает во всех трёх вариантах.

- `doOnSuccess()` - как мы помним, `Maybe` и `Single` вызывают `onSuccess()`, у них нет никаких `onNext()`. Для них есть `doOnSuccess()`, который работает также, как `doOnNext()`. 

Втираем себе в виски понимание того, что **action** операторы ставятся между **observer** и **observable** и отрабатывают _ДО_ **observer**'овских методов.

------

### Combining Observables

#### Merging
Распространённое действие по слиянию двух и более обзёрваблов `<T>` в один `Observable<T>`.

- `Observable.merge()` - если у нас от двух до четырёх однотипных обзёрваблов, можно использовать этот оператор. Аналогично `source1.mergeWith(source2).subscribe(..)`. `Observable.merge()` и оператор `mergeWith()` подпишутся на все источники одновременно, но элементы будут эмититься в одном потоке. Если нам нужен поочерёдный(заданный) эмит элементов, то надо использовать `Observable.concat()`. Не стоит полагаться на порядок эмитов в случае с `merge()`, когда вам нужна какая-то конкретная последовательность элементов. Если такая необходимость всё-таки есть, юзать `concat()`. В случае, когда смёрджить надо больше четырёх обзёрваблов, использовать `Observable.mergeArray()`, который принимает _varargs_ `Observable[]`. Оказывается, можно подать также `Iterable<Observable<T>>` в метод `merge()`, и он нормально отработает. Работает с бесконечными обзёрваблами. 
 
- `flatMap()`- вот на этом операторе надо остановиться подробнее. Производит динамический `Observable.merge()`: берёт каждый эмишн и мапит его в `Observable`. Затем он мёрджит эмишены получившихся `Observable`'ов в один поток.  Простейшее практическое применение для `flatMap()` - смаппить один эмишн в несколько. 
К примеру, мы хотим заэмитить `char` из каждого `String` у `Observable<String>`. Для такой задачи можно использовать` flatMap()`, которому передадим `Function<T, Observable<R>>` в ламбду. Она смапит каждый стринг в `Observable<String>`, который будет эмитить буквы. Надо обратить внимание, что получившийся `Observable<R>` может эмитить любой элемент `R` только если он отличается от входного типа `T`.
```java
Observable<String> source = Observable.just("по", "буквам");
source.flatMap(s -> Observable.fromArray(s.split("")))
	.subscribe(char -> System.out.print(char + " ");
                    
>output: п о б у к в а м
```
Мы разбили каждый стринг на `char`, обернули это в `Observable` и передали в `flatMap()`, который заэмитил все `char`'ы в один поток. 
`flatMap()` также принимает лямбду в виде `BiFunction<T,U,R>`. Изначально заэмиченный тип `T` ассоциируется с `flat-map`'ленным значением `U` и оба эмитятся в значение `R`.
```java
Observable<String> source = Observable.just("Один", "Два")
source.flatMap(s -> Observable.fromArray(s.split("")),
				(s,r) -> s + "-" + r)
		.subscribe(System.out::println);
            
>output:
Один-О
Один-д
Один-и
Один-н
Два-Д
Два-в
Два-а
```
Можно также использовать `flatMapIterable()`, который смапит все `T` эмишены в `Iterable<R>` вместо `Observable<R>`. Потом выпустит все значения `R` для каждого `Iterable<R>`, позволяя пропустить оверхед с запаковыванием его в `Observable`. Есть варианты, которые мапят в `Single`, `Maybe` и `Completable`.

#### Concatenation
Похоже на слияние(_merging_), но с одним ньюансом: эмитит элементы каждого предоставленного обзёрвабла в определённом порядке. Выпуск не перейдёт к следующему обзёрваблу, пока текущий не стрельнёт `onComplete()`. Такой подход гарантирует, что объединяемые источники заэмитят свои элементы в гарантированном порядке. Однако, это хреново, когда речь идёт о бесконечном обзёрвабле. Юзать объединение (_concatenation_), когда нужен чёткий порядок.

- `Observable.concat()` - аналог `Observable.merge(`). Объеденит эмишены разных `Observable` и будет пулять их поочерёдно, переключаясь к следующему источнику только после того, как текущий вызовет `onComplete()`. В простом примере с двумя обзёрваблами, отрабатывает в принципе так же, как `Observable.merge()`, но мы уже вкурили, что в данном случае порядок гарантирован.
Автор пишет, что надо не тупить и не concat'ить бесконечные обзёрваблы, мол, **rxJava** будет ждать `onComplete()`, которого по понятной причине не произойдёт. На крайняк, ставить такой _infinite_ `Observable` вторым в цепочке, чтобы он запускался после первого. (можно вывернуться, кинув `take()`, и спровоцировать этим вызов `onComplete()`).

- `Observable.concatArray()` стригеррит выпуск каждого `Observable` в `Observable[]`. Обычный `Observable.concat()` также спокойно справляется с `Iterable<Observable<T>>` и эмитит их поочереди.

- `concatMapEager()` подпишется на все полученные `Observable`, скэширует эмишены до тех пор, пока не придёт их черёд в очереди.

- `concatMap()` - по аналогии с уже существующим `flatMap()`'ом, который мёрджит обзёрваблы, полученные из каждого эмишена, есть оператор для объединения таких вещей - `concatMap()`. Он предпочтительнее в случае, когда нам важен порядок объединения элементов. Каждый обзёрвабл мапится из эмишна до тех пор, пока тот не завершится. Только потом стартует следующий эмишн. Если источник выпускает больше обзёрваблов, чем `concatMap()` может обработать за промежуток времени, они ставятся в очередь.

Предыдущие примеры `flatMap()`'а больше подходят для `concatMap()`'а, потому что мы паримся об очерёдности. И хотя результатом обоих операторов будет одно и то же, всё таки стоит правильно использовать каждый из них, чтобы потом не удивляться, почему порядок вдруг поплыл (прим.ред). Опять же, использовать `concatMap()` на бесконечных источниках тупо, потому что он работает через `onComplete()`. В таком случае надо брать `flatMap()`.

#### Ambiguous
После слияния(_merge_) и объединения(_concatenation_) надо бы пару слов сказать об _ambiguous_(хрен знает, переводчик топит за "неоднозначный, двоякий").

 - `Observable.amb()` принимает `Iterable<Observable<T>>` и выпускает эмишены первого заэмитившего `Observable`. Остальные в свою очередь высвобождаются.
Первым считается такой обзёрвабл, чьи эмишены проходят через данное звено в чейне(толкование автора). Это полезно, когда у вас несколько источников одних и тех же данных, поэтому вам пофиг откуда их брать, лишь бы побыстрее.
    
#### Zipping
Зиппинг позволяет взять несколько разных эмишенов и объеденить их в один. Типы входных эмишенов могут быть разные, но мы можем объеденить и их тоже.

- Оператор `zip()` работает по принципу молнии: эмишн одного обзёрвабла ждёт эмишн другого, чтобы зазиповаться с ним. Если один обзёрвабл выпалил `onComplete()`, а у другого есть элементы к выпуску, они просто напросто дропнутся.
Можно с таким же успехом использовать `zipWith()`.

- В фабрику `Observable.zip()` вариант подать до девяти `Obsevable`'ов. Если надо больше, то использовать `zip.Array()`.

>Тут надо иметь в виду, что, если один из источников эмитит медленнее, чем остальные, другие источники данных будут тупить и ждать отстающего. Если пофиг на конкретный эмишн и надо взять последний, то можно использовать `combineLatest()`(о нём чуть позже). 
    
#### Combine latest
- `Observable.combineLatest()` - что-то похожее на `zip()`, только отрабатывает с самым последним элементом, выпущенным из любого другого источника. Он не блочит и не ставит в очередь эмишены, которым не нашлось пары, но кэширует их и зипует с последним. Проще говоря, когда один источник эмитит, результат зипуется с последним заэмиченным элементом другого источника. 
Крайне актуально, когда речь идёт о комбинировании **UI** _input_'ов, так как там не важны предыдущие инпуты пользователя, а нужен только последний.

- `withLatestFrom(`) - немного отличается от `combineLatest()`. Он мапит каждый `T` элемент одного эмишена с последним элементом другого, но берёт из каждых эмишенов только _ОДИН_ элемент. В итоге получится, что повторяющихся значений не будет.

#### Grouping
Возможность группировать разные эмишены в отдельные `Observable` - мощнейший инструмент **rxJava**. 

 - Для таких манёвров у неё есть оператор `groupBy()`, который принимает лямбду и маппит эмишн к соотв.ключу. Затем он возвращает `Observable<GroupedObservable<K,T>>`, который эмитит специальный тип `GroupedObservable`. Такой обзёрвабл почти ничем не отличается от обычного, только у него есть значение ключа в качестве свойства.
 
К примеру, у нас есть набор стрингов, которые мы хотим объединить по длине:
```java
Observable<String> source = Observable.just("Кот", "Пёс", "Змея","Либерал");
Observable<GroupedObservable<Integer,String>> byLengths =
source.groupBy(s -> s.lenght());
```
Скорее всего мы захотим использовать flatMap() к каждому элементу `GroupedObservable`, а внутри этого флэтмапа мы захотим собрать результаты в кучу. В таком случае результатом будет `Single`, поэтому и использовать надо `flatMapSingle()`. Давайте вызовем `toList()`, чтобы выпустить эмишены в виде листов с элементами, сгруппированными по длине:
```java
byLengths.flatMapSingle(grp -> grp.toList())
	.subscribe(System.out::prinln);
	
>output:
[Кот, Пёс]
[Змея]
[Либерал]
```
На выходе у нас получились списки с элементами одинаковой длины. (вообще, либерал, конечено, должен был запоковаться вместе с змеёй, но **rxjava** далека от политики и срабатывает чётко, как автомат Калашникова). 
У `GroupedObservable` есть метод `getKey()`, возвращающий ключ, с которым ассоциируется этот обзёрвабл.

-----

### Multicasting, Replaying, and Caching
В этой главе речь будет идти преимущественно о _multicasting_. _Replaying_ и _cashing_ - это на самом деле тоже про мультикаст. Будет и разбор `Subjects`, утилиты, предназначенной для _decoupling_ при мультикасте. Она должна быть использована с умом и в конкретных случаях. Также рассмотрим несколько вариаций _subjects_.

#### Раскуриваем мультикастинг(_multicasting_)
Ранее мы уже имели дело с `ConnectableObservable`, который эмитит элементы всем подписанным `Observer`'aм при вызове метода `connect()`. Такая идея объединения стримов называется мультикастом. 
Но есть некоторые ньюансы, когда речь заходит о применении операторов, которые могут опять создать отдельные стримы.

##### Мультикастинг с операторами
Тут соль в том, _КОГДА_ консолидируются стримы.
 Например, если вызвать мультикастинг(с помощью `publish()`) до оператора `map()`, то стримы будут объеденены в один прокси `Observable` _до_ того, как будет применена мапа. 
 
![](multicast-before-map.png) 
/home/zemlyakov_sv/Desktop/
Затем всё равно будут разные обзёрваблы.
Если мы хотим, чтобы оператор `map()` не генерил нам разные стримы для каждого `Observer`'а,
то `publish()` надо вызывать _ПОСЛЕ_ `map()`.

![](multicast-after-map.png) 

##### Когда собственно нужен мультикаст
В целом эта фича полезна для того, чтобы избежать ненужного повторения одной и той же работы, в тех случаях, когда разные `Observer`'ы используют одни и те же данные. Плюс ко всему это позволяет разгрузить CPU.
Надо помнить, что мультикастинг создаёт горячий `ConnectableObservable`. Тут важно правильно вызвать `connect()`, чтобы ни один из подписчиков не проморгал данные.
Рекомендуется держать ваши обзёрваблы холодными и вызывать `publish()` только когда нужно, чтобы они стали погорячее.
Даже в случае с горячими обзерваблами (типа UI в андроиде), иногда не стоит лишний раз обвешивать их ненужными операторами. Это увеличивает стоимость операции, да и нафига, если у нас, к примеру, один только подписчик. Короче говоря: думать, прежде чем обмазывать всё `publish()`'ем. Вот если у нас несколько `Observer`'ов, то тут можно прикинуть, а не объединить ли их в один стрим.

#### Automatic connection
Вам стопудово когда-нибудь захочется вручную вызывать `connect()`, чтобы типа контролировать эмишены и всё такое. Но есть также варианты из-под капота (с которыми надо быть аккуратнее).

- `autoConnect()` - у `ConnectableObservable` есть такой вот оператор. 
Возвращает `Observable<T>`, который автоматически пульнёт `connect()` после определённого числа подписчиков. Нужен пример? Наврядли, тут всё ясно.
Ради прикола напишу, что автор уточняет: этот оператор не очень полезен, когда мы не знаем точно число `Observer'ов`. Спасибо, чувак, мы это ценим.
А вот это интересно: даже когда целевые обзёрверы отработали или высвободились, `autoConnect()` оставит свою подписку на источник. Если источник конечен и завершает своё выполнение, `autoConnect()` не подпишется на него снова, когда внизу чейна появится новый `Observer`. То есть вновь прибывшие обзёрверы проморгают эмишены. По дефолту, аргумент - 1. 
        
- `refCount() и share()`
	- `refCount()` похож на `autoconnect(1)`, который выстреливает сразу после того, как на него подписался первый обзёрвер. Но есть офигенно важное отличие: после того, как этот чейн отработает, он высвободится. И  перезапустится, когда на него опять кто-нибудь подпишется.
Он не сохраняет подписку на источник, когда у него больше нет обзёрверов.
`refCount()` может быть полезен в случаях, когда надо объединить стримы для каких-то подписчиков, но высвободить эмишн, если вдруг их не осталось. Причём так, чтобы выпуск элементов стартанул вновь после того, как появятся новые подписчики.
	- `publish().refCount()` может быть заменён оператором `share()`.
        
#### Replaying and caching
Мультикастинг также позволяет кэшировать значения, которые делятся между несколькими `Observer`'ами. Повторение и кэширование данных - это фича мультикастинга.
    
##### Replaying
Оператор `replay()` - мощная штука, когда речь идёт о необходисмости сохранить ранее заэмиченные элементы и перевыпустить их, когда коннектится новый `Observer`.
Он вернёт `ConnectableObservable`, который замультикастит эмишены, а также заэмитит ранее выпущенные данные в заданном скоупе (scope).

Закэшированные эмишены выстреливают сразу же после того, как появился новый подписчик, затем будут выпущены текущие элементы. То есть все "опоздавшие" подписчики ничего не пропустят и получат все элементы с самого начала.

Данная операция может быть несколько дороговата, так как `replay()` кэширует все эмишены.
Если задать `bufferSize`, то кэшироваться будет ограниченное количество элементов. `bufferSize(2)` - и вновь подписавшийся получит последние два элемента.
>Обратите внимание: в случае, если мы хотим сохранять кэш для значений в `replay()` даже если у нас нет подписчиков, надо использовать `replay()` в сочетании с `autoConnect()`, а не `refCount()`. Дело в том, что `refCount()` высвобождает и кэш и чейн в целом, поэтому новый подписчик инициирует срабатывание чейна с самого начала.

`replay()` также принимает временнОе значение в качестве аргумента. Повторять за последние T времени (в буфере хранится то, что было выпущено за последние две секунды, например).

##### Caching
Когда вы хотите кэшировать вообще гаддэмн всё, что было выпущено за продолжительный отрезок времени, и вам при этом не надо контролировать поведение подписчиков относительно источника `ConnectableObservable`, можно заюзать оператор `cache()`.

Он подпишится к источнику вместе с первым обзёрвером и сохранит все значения. Это делает его не самым лучшим кандидатом к применению, когда речь идёт о бесконечных источниках.

Как вариант - `cacheWithInitialCapacity()` с количеством элементов, которые надо кэшировать. Важно: не используйте `cache()`, если вам реально не надо сохранять все элементы. Вместо этого лучше использовать `replay()`, так как он позволяет более тонко выбрать стратегию высвобождения чейна и правильно установить ограничения на сохранение элементов.
        
#### Subjects
Прежде всего следует отметить, что у `Subject`'ов есть свои определённые _use-case_'ы, но новички часто усложняют и используют этот инструмент неправильно.
Они представляют из себя одновременно и `Observer` и `Observable`, выступая в роли _proxy multicasting_ устройства (что-то типа _event bus_). Прежде, чем использовать `Subject`'ы, следует убедиться, что вы предприняли все остальные возможные меры. **Erik Meijer**, создатель **RxJava**, называет их "изменяемыми переменными в мире реактивного программирования". Как бы мы не стремились к _immutable_ переменным, без изменяемых переменных всё-равно не обойтись. Аналогичным образом получается и с `Subjects`, которые порой необходимы, чтобы объединить императивное программирование с реактивным.
Прежде, чем объяснять, когда стоит использовать `Subjects`, а когда этого делать не следует, пройдёмся по тому, что они собственно делают.

##### PublishSubject
Есть две абстрактные имплелемнтации `Subject`, которые реализуют одновременно и `Observable` и `Observer`. То есть мы можем вызвать `onNext()`, `onComplete()`, `onError()` у `Subject`'a, и он передаст эти ивенты вниз к `Observer`'ам.
Самый простой пример `Subject` - `PublishSubject`, который бродкастит (_hotly_ выпускает элементы) своим обзёрверам. Другие `Subject` добавляют различные поведения к этой логике, в то время как `PublishSubject` можно считать своего рода ванилью.
```java
Subject<String> subject = PublishSubject.create();

subject.map(String::length)
        .subscribe(System.out::println);
        
subject.onNext("Раз");
subject.onNext("Четыре");
subject.onNext("Двадцать");

>output:
3
6
8
```
Выглядит так, будто `Subject` - магический девайс, мост между императивщиной и реактивщиной. Так оно и есть. Теперь давайте посмотрим, когда его использовать, а когда лучше не стоит.

##### When to use Subjects
Допустим, мы используем **DI** или ещё какой инструмент для инвертирования зависимостей. При таком подходе есть вероятность, что разные модули предоставляют разные `Observable`'ы, которые могут понадобиться нам в рамках одного стрима. Без `Subject`'а это может быть довольно сложным для реализации, так как нам придётся особым образом варить эти обзёрваблы. В обычной ситуации мы бы просто взяли `Observable.merge()` и были бы правы, но это не всегда прокатывает. В целом, `Subjects` помогают избежать жёсткого связывания.
`Subject`'ы хорошо подходят для бесконечных _event-driven_(а это то же самое, что и _action-driven_) `Observables`.

##### When Subjects go wrong
В связи с тем, что `Subject`'ы - горячие обзёрваблы, важно вовремя вызывать `subscribe()`. Делать это следует до того, как мы передаём что-то в `onNext()`. Иначе `Observer` прохлопает эмишены.
Такое положение дел свидетельствует о том, что `Subject`'ы могут быть опасной приблудой, особенно, если вызов `onNext()` происходит где-нибудь хрен знает где. Реактивный подход подразумевает, что исходные `Observable` предоставляются хорошо определённым и предсказуемым источником. Более того, `Subject`'ы не имеют _public_ метода `dispose()` и поэтому не высвободят переданные в них ресурсы, когда внизу по чейну отработает `dispose()`.
Намного лучше держать такие _data-driven_ источники холодными, а затем использовать мультикаст с помощью `publish()` или `replay()`, если вдруг понадобится, чтобы они стали горячими.

>Если вам нужен `Subject`, кастаните его к `Observable` или лучше вообще не используйте его. Можно также сделать обёртку над `Subject`'ом, где методы будут передавать в него соответствующие ивенты.

##### Serializing Subjects
Важно понимать, что все операции над `Subject`'ом, типа `onSubscribe()`, `onError()` и `onComplete()` не являются потокобезопасными! Если несколько потоков вызывают эти методы как им вздумается, выпускаемые элементы могут сломать контракт `Observable`, который требует, чтобы ивенты происходили поочерёдно. Если такое происходит, то хорошей практикой считается вызвать `toSerialized()` к `Subject`'у для того, чтобы запаковать его в безопасный засериализованный вариант сабжекта. Это обезопасит его выполнение в разных потоках и ничего не поломается:
```java
Subject<String> subject = PublishSubject.<String>create().toSerialized();
```

> У компилятора есть ограничения на такие манёвры и нужно указывать тип для метода `create()`. Такая штука не прокатит, если в цепочке после `create()` стоит более одного оператора. Произойдёт ошибка компиляции.
  
##### BehaviorSubject
Ведёт себя примерно так же, как `PublishSubject`, только повторяет последний заэмиченный элемент для каждого вновь подписавшегося обзёрвера. Использование этого `Subject` равносильно использоанию `replay(1).autoConnect()` после `PublishSubject`'а.

##### ReplaySubject
Эквивалент `PublishSubject`'а, дополненного оператором `cache()`. Он незамедлительно отлавливает эмишены вне зависимости, подписан на него кто-нибудь или нет, и кэширует их. Каждый вновь подписанный обзёрвер получит ранее выпущенные и закэшированные элементы. Очевидно, использовать надо с умом, когда речь идёт о каких-то больших объёмах данных.

##### AsyncSubject
Пушит только последнее значение, которое получает перед тем, как отработает `onComplete()`.

> В принципе повторяет поведение `CompletableFuture` из восьмой джавы: произведёт необходимое нам вычисление над выбранным элментом, как только он отработает. Можно эмитировать с помощью `takeLast(1).replay(1)`. Попробуйте сначала выполнить такой приём прежде, чем использовать `AsyncSubject`.

##### UnicastSubject
Может оказаться полезным сабжектом, если нам надо поместить в буфер все эмишены в стриме до тех пор, пока на него кто-нибудь не подпишется, а затем выпалить все эмишены этому подписчику и освободить буфер.
Будет работать только с одним `Observer`, когда тот подпишется. Выкинет ошибку, если вдруг появятся ещё какие-то подписчики. Это логично, так как буфер очищается сразу после того, как первый подписчик получает все выпущенные элементы. Следующим обзёрверам просто напросто нечего получать. Если вы хотите, чтобы остальные тоже получили свои эмишены, надо использовать `ReplaySubject`. Плюс данного сабжекта в том, что он очищает память, которая была использована для буферизации.

-----

### Concurrency and Parallelization

> Для глубокого понимания Java concurrency автор советует книгу Brian Goetz: Java Concurrency in Practise.

Создание потоков - дорогая операция. Лучше _переиспользовать_ их и заставлять выполнять очередь из задач.

#### Introducing RxJava Concurrency
По дефолту, `Observable` выполняет работу в том же потоке, в котором был создан и подписан `Observer`. Почти во всех предыдущих примерах это был _main thread_, который запускался функцией `public static void main()`.
Но были некоторые оговорки, к примеру, в случае с `Observable.interval()`. Этот обзёрвабл запустит поток вне _main thread_'а, который в свою очередь не будет ждать его выполнения. Такой обзёрвабл делает из нашей приложухи многопоточное приложение, так как речь уже идёт как минимум о двух _thread_'ах.

Зачастую, _concurrency_ полезно, когда нужно выполнять какие-то жирные долгоиграющие операции.

- `subscribeOn()` - позволяет задать конкретный `Scheduler` для обозначенного источника. Задача `Scheduler`'а - предоставить _thread_ для выполнения той или иной операции. Он хранит пул _thread_'ов. После вызова `onComplete()`, _thread_ будет отдан обратно его шедулеру, таким образом его можно будет переиспользовать где-нибудь в другом месте.

`Observable`'ам безразлично на каком потоке они выполняются. **RxJava** неплохо справляется с многопоточностью даже в случаях, когда нам нужно скомбинировать результаты выполнения разных обзёрваблов из разных потоков.

> Если нужно иметь дело с высоконагруженными `Observable`'ами, которые эмитят 10К и более элементов, то стоит работать с `Flowable`.

#### Keeping an application alive
Когда мы работаем с фрэймворками, которые поддерживают выполнение главного потока (Android, JavaFX, ещё там какие-нить), то мы не паримся насчёт того, живо наше приложение или нет. Эти фреймворки работают за нас. Ситауция обстоит несколько иначе, когда нам нужно работать из `main()`. Тут придётся заставлять главный поток спать, либо идти на ещё какие-нибудь ухищрения. Можно в принципе бесконечно усыпить его, подав `Long.MAX_VALUE` в `Thread.sleep()` (_main_ поток уснёт на 292 года).

Есть способы поддержать жизнеспособность приложения ровно на столько, чтобы выполнились все операции в _subscription_. Brian Goetz писал про такие стандартные тулзы, как `CountDownLatch`, которые могут подождать выполнения двух подписок. Но намного проще заюзать блокирующие операторы(_blocking operators_) **RxJava**.

Обчычно, _blocking operators_ используются в Unit-тестах. Могу породить анти-паттерны при бездумном использовании в продакшн-коде.

#### Understanding Schedulers
_Thread-pools_ являются коллекциями потоков. Эти потоки сохраняются и переиспользуются в соответствии с политикой пулла. 

Некоторые пулы имеют фиксированное количество потоков (такие, как `computation()`),   в то время, как другие динамически создают и уничтожают потоки по мере надобности. В стандартной джаве вы используете `ExecutorService` в качесестве _thread pool_'а. **RxJava** предоставляет свою абстракцию для таких нужд - `Scheduler`. Он определяет методы и правила, которые такой провайдер потоков, как `ExecutorService`, должен выполнять. 

Большинство стандартных шедулеров могут быть получены из статического класса-фабрики `Schedulers`. Когда отработает `onComplete()`, операция высвободит ресурсы и поток вернётся обратно в свой пул, где он может быть сохранён и переиспользован другим `Observer`'ом.

##### Computation
Содержит фиксированное количество _thread_'ов, основанное на доступных процессорах для текущей сессии Java. Это делает данный шедулер более подходящим для выполнения вычислительных задач(таких, как математические, алгоритмические, сложные логические), которые могут занимать ядро чуть более чем полностью. К тому же, нет смысла выделять больше потоков, чем количество ядер, чтобы проделать такого рода работу. 

> Если не уверен, какой шедулер выбрать, пикай computation(), не прогадаешь.

Такие операции, как `interval()`, `delay()`, `timer()`, `timeout()`, `buffer()`, `take()`, `skip()`, `takeWhile()`, `skipWhile()` и некоторые другие использует этот шедулер по умолчанию.

##### IO
Задачи по вводу-выводу, такие, как запись и чтение в БД, запросы в сеть - менее затратны для **CPU** и чаще всего занимают сравнительно немного времени, чтобы выполниться. Это значит, что можно более свободно создавать _thread_'ы и `Schedulers.io()` отлично для этого подходит. Он будет обеспечивать работу стольких потоков, сколько нужно. Этот шедулер поддерживает динамическое увеличение/уменьшение пула потоков и их кэширование.

> Каждый новый _subscription_ будет вызывать создание нового _thread_'а.

##### New thread
`Schedulers.newThread()` вернёт `Scheduler`, у которого нет пула потоков. Он будет создавать новый поток для каждого нового `Observer` и уничтожать этот поток, как только тот отработает. Эта логика отличается от `Schedulers.io()` тем, что данный шедулер не будет пытаться закэшировать и сохранить потоки для переиспользования.

Это может быть полезно, когды мы хотим создать поток и сразу уничтожить его после решения поставленной задачи. Использовать следует аккуратно, чтобы не крашнуть приложение.

##### Single
Когда вы хотите обеспечить поочерёдное выполнение задачи на одном потоке, вам нужен этот шедулер. У него под капотом реализована однопоточная логика, что часто полезно для цикличных ивентов. Он может пригодиться, чтобы изолировать потоко-небезопасную работу.
```java
Observable.just("We", "love", "Putin")
            .subscribeOn(Schedulers.single());
```

##### Trampoline
Это интересный шедулер. Он про незамедлительное выполнение, но предотвращает случаи рекурсивной работы, когда задача шедулит другую задачу на том же самом потоке. Вместо того, чтобы выдать _stack overflow error_, этот шедулер позволит сначала завершиться текущей задаче, и только потом начнёт выполнение следующей. 

##### ExecutorService
Можно запилить свой собственный шедулер поверх стандартного `ExecutorService`. Такой финт ушами понадобится в случае, если надо более тонко контролировать потоки, их выполнение и вот это вот всё. К примеру, нам нужен шедулер, который будет использовать 20 _thread_'ов. Можно создать `ExecutorService` с заданным количеством потоков и подать его в `Schedulers.from()`:
```java
int numberOfThreads = 20;
ExecutorService executor = 
    Executors.newFixedThreadPool(numberOfThreads);
    
Scheduler scheduler = Schedulers.from(executor);

Observable.just("Check", "this", "out")
            .subscribeOn(scheduler)
            .doFinally(executor::shutdown)
            .subscribe(System.out::println);
```
`ExecutorService` будет держать вашу приложуху живой до конца времён, поэтому надо вручную говорить ему о завершении. Вот почему в примере вызыван `executor::shutdown`.

##### Starting and shutting down Schedulers
Каждый дефолтный шедулер лениво инстанциируется, когда вы в первый раз его используете. Можно высвободить `computation()`, `io()`, `newThread()`, `single()`, `io()` в любое время, вызвав метод `shutdown()` у каждого, или можно освободить сразу все через `Schedulers.shutdown()`. Это остановит все выполняющиеся потоки и запретит выполнение новых задач. Чтобы возобновить работу стандартных шедулеров, надо будет вызывать `Schedulers.start()`.

> В десктопных и мобильных приложениях _start_ и _stop_ шедулеров не так актуален. 

#### Understanding subscribeOn()

 

 
