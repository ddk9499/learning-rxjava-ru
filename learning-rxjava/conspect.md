### Что это такое

Это конспект-перевод книги Томаса Нилда "Learning RxJava", 2017

<ul>
<img src="https://github.com/rcd27/workbook/blob/master/learning-rxjava/learning-rxjava.jpg" width="250">
</ul>

-----

### Структура

Для того, чтобы упростить навигацию по материалу, была сохранена оригинальная структура книги: все оглавления и заголовки остались в родном виде.

 - [Chapter 2: Observables and Subscribers](#observables-and-subscribers)
    - [The Observable](#observable)
        - How Observables work
        - Using Observable.create()
        - Using Observable.just()
    - [The Observer interface](#Интерфейс-observer)
        - Implementing and subscribing to an Observer
        - Shorthand Observers with lambdas
    - [Cold versus hot Observables](#cold-vs-hot)
        - Cold Observables
        - Hot Observables
        - ConnectableObservable
    - [Other Observable sources](#Другие-фабрики-для-создания-observable)
        - Observable.range()
        - Observable.interval()
        - Observable.future()
        - Observable.empty()
        - Observable.never()
        - Observable.error()
        - Observable.defer()
        - Observable.fromCallable()
    - [Single, Completable, and Maybe](#single-completable-maybe)
        - Single
        - Maybe
        - Completable
    - [Disposing](#disposing)
        - Handling a Disposable within an Observer
        - Using CompositeDisposable
        - Handling Disposal with Observable.create()

- Chapter 3: Basic Operators
    - Suppressing operators
        - filter()
        - take()
        - skip()
        - takeWhile() and skipWhile()
        - distinct()
        - distinctUntilChanged()
        - elementAt()
    - Transforming operators
        - map()
        - cast()
        - startWith()
        - defaultIfEmpty()
        - switchIfEmpty()
        - sorted()
        - delay()
        - repeat()
        - scan()
    - Reducing operators
        - count()
        - reduce()
        - all()
        - any()
        - contains()
    - Collection operators
        - toList()
        - toSortedList()
        - toMap() and toMultiMap()
        - collect()
    - Error recovery operators
        - onErrorReturn() and onErrorReturnItem()
        - onErrorResumeNext()
        - retry()
    - Action operators
        - doOnNext(), doOnComplete(), and doOnError()
        - doOnSubscribe() and doOnDispose()
        - doOnSuccess()

- Chapter 4: Combining Observables
    - Merging
        - Observable.merge() and mergeWith()
        - flatMap()
    - Concatenation
        - Observable.concat() and concatWith()
        - concatMap()
    - Ambiguous
    - Zipping
    - Combine latest
        - withLatestFrom()
    - Grouping

- Chapter 5: Multicasting, Replaying, and Caching
    - Understanding multicasting
        - Multicasting with operators
        - When to multicast
    - Automatic connection
        - autoConnect()
        - refCount() and share()
    - Replaying and caching
        - Replaying
        - Caching
    - Subjects
        - PublishSubject
        - When to use Subjects
        - When Subjects go wrong
        - Serializing Subjects
        - BehaviorSubject
        - ReplaySubject
        - AsyncSubject
        - UnicastSubject

- Chapter 6: Concurrency and Parallelization
    - Why concurrency is necessary
    - Concurrency in a nutshell
        - Understanding parallelization
    - Introducing RxJava concurrency
        - Keeping an application alive
    - Understanding Schedulers
        - Computation
        - IO
        - New thread
        - Single
        - Trampoline
        - ExecutorService
        - Starting and shutting down Schedulers
    - Understanding subscribeOn()
        - Nuances of subscribeOn()
    - Understanding observeOn()
        - Using observeOn() for UI event threads
        - Nuances of observeOn()
    - Parallelization
    - unsubscribeOn()

- Chapter 7: Switching, Throttling, Windowing, and Buffering
    - Buffering
        - Fixed-size buffering
        - Time-based buffering
        - Boundary-based buffering
    - Windowing
        - Fixed-size windowing
        - Time-based windowing
        - Boundary-based windowing
    - Throttling
        - throttleLast() / sample()
        - throttleFirst()
        - throttleWithTimeout() / debounce()
    - Switching
    - Grouping keystrokes

-----

### Observables and Subscribers
Фундаментальная идея в основе реактивного программирования: события - это данные, данные - это события.

#### `Observable`
 
- `onNext()` - передаёт каждый элемент вниз до `Observer`.
- `onComplete()` - свидетельствует о том, что нет больше никаких `onNext()`.
- `onError()` - отправляет ошибку вниз по цепочке вплоть до самого `Observer`, где , как правило, определена обработка ошибок. Если не использован оператор `retry()` или один из [методов](https://github.com/ReactiveX/RxJava/wiki/Error-Handling-Operators) вида `onErrorResumeNext()`, то по контракту больше никаких элементов не заэмитится.
 
`Observable.create()` -  фабрика, позволяющая создать `Observable` и обозначить эмиттер. Нужна для хуков вокруг нереактивных источников данных/событий. В первой **RxJava** это был `Observable.fromEmitter()`. Стоит обратить внимание, что `Observable` может эмитить один элемент за период времени. `map()` и `filter()` возвращают новый `Observable`.

Во второй **RxJava** нельзя эмиттить Null.

#### Интерфейс `Observer`
Методы `onNext()`, `onComplete()`, `onError()` определяют тип обзёрвера. В первой эрыксджаве это был `Subscriber`. Во второй `Subscriber` появляется только когда речь идёт о `Flowables`. Если при выпуске элементов в `Observable` произойдёт ошибка, то она упадёт в `Observer.onError()`.
    
#### Функции в rxJava (аналогично Java8)

Имя | single-abstract-method | Описание
--------|---------|-----------
`Action` | `run()` | Запускает операцию, похоже на `Runnable`
`Callable<T>`	| `get()` | Возвращает элемент типа `T`
`Consumer<T>` | `accept()` | Что-то делает над `T`, ничего не возвращает
`Function<T,R>` | `apply()` | Принимает `T`, возвращает `R`
`Predicate<T>` | `test()` | Принимает `Т`, возвращает `boolean`
`BiConsumer<T1,T2>` | `accept()` | см.`Consumer<T>`
`BiFunction<T1,T2,R>` | `apply()` | Принимает `T1`, `T2`, возвращает `R`
`BiPredicate<T1,T2>`	| `test()` | см.`Predicate<T>`
`Function3<T1,T2,T3,R>` | `apply()` | Принимает три аргумента, возвращает `R`
`BooleanSupplier` | `getAsBoolean()` | Возвращает булю
`LongConsumer` | `accept()` | Что-то делает с входным лонгом и всё
`IntFunction` | `apply()` |	Принимает `int` и возвращает `T`	
			
#### Cold vs Hot
Обсерваблы, которые эмитят конечные данные чаще всего _cold_ (отрабатывают тогда, когда на них подписались). Горячие похожи на _broadcast_, вещают всем подписчикам.
Работает, как радио. Если пропустил трэк, его уже не услышишь. Горячие чаще всего отображают события, нежели какие-то данные.

`ConnectableObservable` - полезная форма горячего обзёрвабла. Он берёт любой Observable и делает из него _hot_, чтобы он эмитил всем подписчикам одновременно.
Просто вызови `publish()` у любого обзёрвабла и он вернёт `ConnectableObservable`.
Но subscribe на такой обзёрвабл не вызовет эмиты. У него надо вызвать `connect()`, чтобы тот начал пулять. То есть можно подписать несколько на `ConnectableObservable`, потом ткнуть `source.connect()`, и только тогда все подписчики получат свои данные. Такая фиговина более известна, как _Multicasting_.

#### Другие фабрики для создания Observable
- `Observable.range()` - для создания последовательности интов. Создаётся до тех пор, пока не будет достигнут конечный инт. Все инты передаются через `onNext()`, что неудивительно.

- `Observable.interval()` - _time-based_ обзёрвабл, который эмитит с заданным
интервалом. Бесконечный. _Cold_.

- `Observable.future()` - хер его знает, не особо-то описано. Обёртка над `Future`.

- `Observable.empty()` - ничего не эмитит и вызвает `onComplete()`. Вместо *null*'ов.

- `Observable.never()` - похож на `empty()`, только никогда не вызывает `onComplete()`.

- `Observable.error()` - вызывает `onError()`.

- `Observable.defer()` - какая-то мощная фиговина, так как может создавать _separate state_(отдельное состояние) для каждого `Observable`. Ну например нам нужно подтягивать изменившееся состояние в обзёрвабл.

- `Observable.fromCallable()` - если нам надо произвести какое-то вычисление или операцию, а затем заэмитить его/её, можно просто вызвать `Observable.just()`.
Но иногда надо это проделать лениво. Также, если эта операция вызывает ошибку, лучше бы она её выкидывала только на момент выполнения чейна.
Более того, если в `Observable.just()` случится ошибка, то она не будет передана в `Observer`. Короче говоря, если то, что вы оборачиваете в `Observable` может вызывать ошибку, то оборачивать надо в `Observable.fromCallable()`.

#### Single, Completable, Maybe
Есть три разных типа обзёрваблов, которые эмитят ноль или один элемент.

- `Single` - эмитит, вот это поворот, один элемент. `onSuccess()` включает в себя `onNext()` и `onComplete()`. В лямбде, соответственно, ловится `onSuccess()` и `onError()`.

- `Maybe` - если количество элементов от 0 до 1.

- `Completable` - придуман для того, чтобы выполнять какое-то действие. Ничего не получает. Есть `onError()` и `onComplete()`.

#### Disposing
Когда мы вызываем `subscribe()`, создаётся поток и обрабатывает emissions в цепочке. Для этого выделяются какие-то ресурсы. Слава Богу, `Observable` высвобождает эти ресурсы как только отрабатывает `onComplete()`. Но в случае, если у нас бесконечный или турбо долгий поток, нам может понадобится конкретный `dispose`.
Короче, нельзя доверять **GC** чистку толстых потоков, надо диспозить самому, чтобы избежать мемори ликов.
`Disposable` - это связующее звено между `Observable` и активным `Observer`. Можно вызывать его `dispose()` для того, чтобы прекратить эмитить элементы и высвободить все ресурсы, затраченные на их выпуск.

##### Disposable в обзёрвере
В `onSubscribe(Disposable d)` у обзёрвера передан `Disposable`. Это нужно для того, чтобы обзёрвер мог контролировать подписку и у него был вариант отписаться в любой момент. `Disposable` передаётся по всей цепочке обзёрваблов. Вообще, передача `Observer`'a в `subscribe()` не вернёт `Disposable` (rxJava сама захэндлит это вот всё), но если очень надо, то можно юзануть `subscribeWith(Disposable)`, тем самым получив дефолтный `Disposable`.

Использование `CompositeDisposable`. НужнО в случае, если у нас несколько подписок, а мы хотим манагить их (отписаться от всех разом, к примеру).

-----

### Basic Operators
Тут важно вкурить, что операторы сами являются `Observer`'ом для своего `Observable` выше по цепочке.

#### Suppressing operators
Эти операторы просто тупо не вызывают `onNext()`, если не проходит какое-то условие. Соответственно, элемент не проходит вниз по цепочке.

- `filter()` - принимает `Predicate<T>` для обзёрвабла `T`. Каждый эмишн мапится в булю, которая говорит - подходит данный эмишн к условию или нет. Эмишены `False` дальше не проходят. Если вообще нет подходящих вариантов, то вернётся пустой `Observable`, ферштейн?

- `take()` - у него несколько реализаций, тривиально.

- `skip()` - противоположно `take()`.

- `takeWhile()`, `skipWhile()` - принимает/пропускает, пока соответствует условию.

- `takeUntil()`, `skipUntil()` - принимают другой `Observable` в качестве параметра. Принимают/пропускают, пока другой обзёрвабл продолжает эмитить.

- `distinct()` - будет эмитить каждый уникальный элемент, но подавлять повторяющиеся. Сравнение работает на `hashcode()`/`equals()` выпускаемых объектов. Надо иметь в виду, что если если у нас дохрена уникальных элементов, то этот оператор будет есть память. Типа как если бы каждая подписка создавала `HashSet`, отслеживающий предыдущие выпущенные элементы. Можно также кинуть в `distinct()` лямбду, по которой будет отобран уникальный ключ.

- `distinctUntilChanged()` - полезная штуковина. Эмитит элементы, если входящие значения изменились. То есть она игнорит последовательно повторяющиеся элементы.
`2,2,3,3,3,1,1 -> 2,3,1`. Также принимает лямбду на вход, по которой собственно сравнивает элементы.

- `elementAt()` - можно получить специфичный эмишн по его id'шнику (`long` от 0 до `Long.MAX_VALUE`). Возвращает `Maybe<T>`. У него есть разные реализации:
	- `elementAtOrError()` -  вернёт `Single` или `Error` (в случае, если по данному индексу нифига нет).
	- `singleElement()` - вернёт Observable, обёрнутый в Maybe
	- `firstElement()` и `lastElement()`.

#### Transforming operators
- `map()` - для заданного `Observable<T>` меняет `T` на `R`, используя функцию `Function<T,R>`.
Конвертирует один-к-одному каждый эмишн. Если нужно конвертить один-к-нескольким эмишнов, то надо использовать `flatMap()` или `concatMap()`.

- `cast()` - _map-like_ оператор, который кастует каждый эмишн к заданному типу. Некий такой брут-форс для приведения типов. Лучше правильно юзать дженерики, разумеется.

- `startWith()` - позволяет нам впихнуть какой-нибудь эмишн, с которого начинаются другие эмишны.
Например, у нас есть `Observable<String>`,выпускающий элементы, которые мы хотим напечатать в менюшке. Можно использовать `startWith()`, чтобы сначала написать заголовок менюшки.
```
Observable.just("Чай", "Кофе", "Лимонад")
	.startWith("НАПИТКИ")
	.subscribe(System.out::println)
	
>output: 
		НАПИТКИ 
		Чай
		Кофе
		Лимонад
```
Если нам нужно больше, чем один элемент для старта, можно бахнуть

- `startWithArray()`, тогда отработают сначала элементы массива. Если нужно ждать выпуск всех эмишнов другого `Obsaervable`, стоит использовать `Observable.concat()` или `concatWith()`.

- `defaultIfEmpty()` - подставляет дефолт, если пусто. Вот это да.

- `switchIfEmpty()` - переключается на другой `Observable`, если предыдущий не заэмитил ни одного элемента.

- `sorted()` - если у нас есть конечный `Observable<T>`, который выпускает элементы `Comparable<T>`, можно юзать этот оператор, чтобы сортировать эмишены. Под капотом он соберёт все эмишены, а потом перевыпустит их в заданном порядке. Если применить к бесконечному `Observable`, получим `OutOfMemory`, естесна. Можно подать `Comparator` в качестве аргумента.

- `delay()` - собирает все элементы и выпускает затем один за одним с заданным интервалом. Так как оперирует на другом шедулере, то надо это иметь в виду и не тупить в посках выполненной операции. Она могла не успеть выполниться до завершения _main_-потока. Для применения продвинутого `delay()` можно подать в него другой `Observable`, и этот дилей отложит свои эмишены на время, пока данный обзёрвабл чё-нить не выпустит. Есть также такая штука, как `delaySubscription()`, которая откладывает подписку, а не выпуск эмишнов.

- `repeat()` - повторит подписку после `onComplete()` заданное количество раз. Есть ещё `repeatUntil()`, который принимает `BooleanSupplier` и продолжает повторения до тех пор, пока супплаер не выдаст `true`.

- `scan()` - _rolling_ аггрегатор. Аккумулирует каждый эмишн и добавляет его к следующему.

```java
Observable.just(5, 3, 7, 10)
	.scan((accumulator, next) -> accumulator + next)
	.subscribe(System.out::println)

>output: 5 8 15 25
```

Это не обязательно лепить для интеджеров, можно аккумулировать всё что угодно. Отличается от `reduce()` тем, что тот берёт один эмишн, когда отрабатывает `onComplete()`. Может использоваться в бесконечных обзёрваблах.

#### Reducing operators
Будут случаи, когда необходимо взять серии эмишенов и сконсолидировать их в один элемент (зачастую какой-нибудь `Single`). Для этого есть несколько операторов. Заметьте, что эти операторы работают только с конечным `Observable`, который вызывает `onComplete`.

- `count()` - простейший оператор для объединения множества эмишенов. Он подсчитает количество элементов и выпустит `Single`, когда отработает `onComplete()`. Если нужно посчитать эмишены на бесконечном обзёрвабле, юзать `scan()`.

- `reduce()` - синтаксически похож на `scan()`, но только выдаёт последнее саккумулированное значение. Может выдать `Single` или `Maybe` в зависимости от вашей имплементации. Например, если нужон общий интеджер:
```java
Observable.just(5, 3, 7, 10, 2, 14)
	.reduce((total, next) -> total + next)
	.subscribe(System.out::println)

>output: 41
```

- `all()` - эта хреновена проверяет, что все элементы подпадают под определённый критерий и возвращает `Single<Boolean>`. Как только один из элементов не совпадает, **сразу** возвращает `False`.
>Не тупи и запомни: если вызвать `all()` к пустому обзёрваблу, он выдаст `True`.

- `any()` - соответственно, если есть хотя бы один подходящий эмишн. 
>Кстати, если вызвать его у пустого обзёрвабла, то он выдаст `False`.

- `contains()` - тут всё просто: вырнёт булю, если в эмишеннах есть данный элемент. Работает на `hashCode()`/`equals()`.

#### Collection operators
Аккумулируют все эмишены и собирают в одну коллекцию, типа листа или мапы. Затем выплёвывают эту коллекцию. Являются на самом деле ещё одной формой  _reducing operators_, но достойны отдельного параграфа. Кстати да, не стоит злоупотреблять этими операторами, так как это может навредить вашей реактивщине: лучше обрабатывать ивенты один-за-другим, так же, как они эмитятся, нежели скидывать всё в кучу и потом разгребать её. Смысл эрыкса тогда?

- `toList()` - собирает все эмишены из `Observable<T>` в `List<T>` и выдаёт его в виде `Single<List<T>>`. После того, как `Observable` отстреливает `onComplete()`, лист пушится в обзёрвер. По дефолту, этот лист будет `ArrayList`'ом, можно передать _capacity_ и задать таким образом ограничение на количество элементов.

- `toSortedList()` - собирает в сортированный лист (работает на `Comparator`'ах). Соответственно, можно передать компаратор в качестве аргумента.

- `toMap()` - для заданного `Observable<T>` соберёт в `Map<K,T>`, где `K` - ключ, полученный из лямбды `Function<T,K>`.

```java
Observable.just("Раз", "Два", "Три")
	.toMap(s -> s.charAt(0))
	.subscribe(System.out::println)

>output: {Р=Раз, Д=Два, Т=Три}
```

Можно и посложнее смаппить, если в лямбду передать через запятую правило для `value`.

```java
... 
	.toMap(s-> s.charAt(0), String::length)
	.subscribe(..)

>output: {Р=3, Д=3, Т=3}
```

По дефолту `toMap()` использует `HashMap`, можно обеспечить `ConcurrentHashMap`: `.toMap(s-> s.charAt(0), String::length, ConcurrentHashMap::new)`.

- `toMultiMap()` поддерживает случаи, когда хэши совпадают. Значения в таком случае складываются в список.

- `collect()` - нужен, чтобы собрать элементы в специфическую коллекцию:
`.collect(HashSet::new, HashSet::add)` соберёт в `HashSet` и выдаст `Single<HashSet>`. Используйте `collect()` вместо `reduce()`, когда вы собираете эмишены в мутабельный объект, чтобы затем получить _sealed_ объект.
Хороший пример с **guava**:

```java
Observable.just("Оп", "Оп", "Опана")
// собрали в билдер все элементы
	.collect(ImmutableList::builder, ImmutableList::add)
// сбилдили неизменяемый гуавовский список
	.map(ImmutableList.Builder::build)
	.subscribe(..)
```

В общем `collect()` хорош для сбора элементов в любую "нестандартную"
для rxjava коллекцию.
        
#### Error recovery operators
Так, ну мы уже знаем про метод `onError()`, который пронизывает всю цепочку от `Observable` до `Observer`. После его срабатываения, поток завершает выполнение и никаких эмишенов больше не происходит. Но иногда нам надо перехватить ошибку _до_ того, как она провалится до `Observer`'a и поток завершится с ошибкой.

- `onErrorReturn()` и `onErrorReturnItem()` - когда нужно вернуть дефолтный элемент в случае ошибки. Принимает лямбду с `Throwable`'ом. Важно, где стоит в цепочке. Чтобы ловить ошибку, должен стоять после обзёрвабла, который выдал эту ошибку (логично, потому как каждый следующий член цепочки является `Observer`'ом предыдущего члена и `Observabl`'ом для следущего).

- `onErrorResumeNext()` - аналогичен предыдущим, только принимает ещё другой `Observable` в качестве параметра (который эмитится на случай ошибки). Можно по красоте бахнуть например `.onErrorResumeNext(Observable.empty())` и вызвать тем самым `onComplete()` в цепочке, где произошла ошибка. Искать только её потом устанем (прим.автора).

- `retry()` - переподписывается к `Observabl`'у в надежде, что ошибка рассосётся сама по себе. Есть несколько перегруженных методов. Можно, например, задать интом количество попыток. Можно пульнуть в него `Predicate<Throwable>` или `BiPredicate<Integer,Throwable>`, чтобы более точно описать случай, когда должен отработать `retry()`. `retryUntil()` будет пересабскрайбиться до тех пор, пока соотв. `BooleanSupplier` в лямбде выдаёт `false`. Есть также крутой `retryWhen()`. С его помощью можно применить композицию из задач для ретрая (к примеру, выставить `delay` для `retry`).

#### Action operators
Помогают при дебаге, улучшают понимание того, что собственно проиходит в чейне. Вставлять между целевым обзёрвером и его обзёрваблом (прим.автора).
	
- `doOnNext()` - позволяет брать эмишены предыдущего `Observable`'а. Что-то типа мини-обзёрвабла в середине цепочки. Он никак не меняет эмишены. С помощью `doOnNext()` мы просто создаём _side-effect_ для каждого ивента в цепочке. В этом примере мы просто выведем все стринги в консоль до того, как они упадут в оператор `map()`:

```java
Observable.just("One", "Four", "Twelve")
	.doOnNext(s -> System.out::println)
	.map(String::length)
	.subscribe(System.out::println)

>output: One 3 Four 4 Twelve 6
```

Есть также `doAfterNext()`, который предпринимет заданное действие _ПОСЛЕ_
того, как эмишн ушёл дальше по цепочке.

- `doOnComplete()` - срабатывает, когда чейн вызывает свой `onComplete()`. Может быть полезен в случае, когда нужно понять, какая часть цепочки отработала нормально и завершилась `onComplete()`. 
		
- `doOnError()` - соответственно, срабатывает, когда по цепочке пробрасывается ошибка. Опять же, полезно вставлять между операторами. Тут лучше с примером:

```java
Observable.just(5, 2, 4, 0, 3, 2, 8)
	.doOnError(e -> System.out.println("Source failed")
	.map(i -> 10/i)
	.doOnError(e -> System.out.prinln("Division failed!")
	.subscribe(i -> System.out::println,
				e -> System.out.println("Observer gets error");

> output: 2 5 2 Division failed! Observer gets error
```

То есть "Source failed" не отработал, так как не было выпущено никаких ошибок из `.just(...)`.
Есть также `doOnEach()`, где мы можем определить действие для всех трёх предыдущих операторов. Это типа как влепить `subscribe()` посередине чейна.
		
- `doOnSubscribe()` - выпускает `Consumer<Disposable>` в момент, когда в чейне срабатывает подписка. Предоставляет доступ к `Disposable` на случай, если нам нужно вызвать `dispose()`.

- `doOnDispose()` - позволяет предпринять какую-то операцию в момент, когда в чейне отработал `dispose()`. 
>Если нам нужно сделать что-то в любом случае, будь то `onComplete()`, `onError()` или `dispose`, нам понадобится `doFinally()`, который отрабатывает во всех трёх вариантах.

- `doOnSuccess()` - как мы помним, `Maybe` и `Single` вызывают `onSuccess()`, у них нет никаких `onNext()`. Для них есть `doOnSuccess()`, который работает также, как `doOnNext()`. 

Втираем себе в виски понимание того, что **action** операторы ставятся между **observer** и **observable** и отрабатывают _ДО_ **observer**'овских методов.

------

### Combining Observables

#### Merging
Распространённое действие по слиянию двух и более обзёрваблов `<T>` в один `Observable<T>`.

- `Observable.merge()` - если у нас от двух до четырёх однотипных обзёрваблов, можно использовать этот оператор. Аналогично `source1.mergeWith(source2).subscribe(..)`. `Observable.merge()` и оператор `mergeWith()` подпишутся на все источники одновременно, но элементы будут эмититься в одном потоке. Если нам нужен поочерёдный(заданный) эмит элементов, то надо использовать `Observable.concat()`. Не стоит полагаться на порядок эмитов в случае с `merge()`, когда вам нужна какая-то конкретная последовательность элементов. Если такая необходимость всё-таки есть, юзать `concat()`. В случае, когда смёрджить надо больше четырёх обзёрваблов, использовать `Observable.mergeArray()`, который принимает _varargs_ `Observable[]`. Оказывается, можно подать также `Iterable<Observable<T>>` в метод `merge()`, и он нормально отработает. Работает с бесконечными обзёрваблами. 
 
- `flatMap()`- вот на этом операторе надо остановиться подробнее. Производит динамический `Observable.merge()`: берёт каждый эмишн и мапит его в `Observable`. Затем он мёрджит эмишены получившихся `Observable`'ов в один поток.  Простейшее практическое применение для `flatMap()` - смаппить один эмишн в несколько. 
К примеру, мы хотим заэмитить `char` из каждого `String` у `Observable<String>`. Для такой задачи можно использовать` flatMap()`, которому передадим `Function<T, Observable<R>>` в ламбду. Она смапит каждый стринг в `Observable<String>`, который будет эмитить буквы. Надо обратить внимание, что получившийся `Observable<R>` может эмитить любой элемент `R` только если он отличается от входного типа `T`.

```java
Observable<String> source = Observable.just("по", "буквам");
source.flatMap(s -> Observable.fromArray(s.split("")))
	.subscribe(char -> System.out.print(char + " ");
                    
>output: п о б у к в а м
```

Мы разбили каждый стринг на `char`, обернули это в `Observable` и передали в `flatMap()`, который заэмитил все `char`'ы в один поток. 
`flatMap()` также принимает лямбду в виде `BiFunction<T,U,R>`. Изначально заэмиченный тип `T` ассоциируется с `flat-map`'ленным значением `U` и оба эмитятся в значение `R`.

```java
Observable<String> source = Observable.just("Один", "Два")
source.flatMap(s -> Observable.fromArray(s.split("")),
				(s,r) -> s + "-" + r)
		.subscribe(System.out::println);
            
>output:
Один-О
Один-д
Один-и
Один-н
Два-Д
Два-в
Два-а
```

Можно также использовать `flatMapIterable()`, который смапит все `T` эмишены в `Iterable<R>` вместо `Observable<R>`. Потом выпустит все значения `R` для каждого `Iterable<R>`, позволяя пропустить оверхед с запаковыванием его в `Observable`. Есть варианты, которые мапят в `Single`, `Maybe` и `Completable`.

#### Concatenation
Похоже на слияние(_merging_), но с одним ньюансом: эмитит элементы каждого предоставленного обзёрвабла в определённом порядке. Выпуск не перейдёт к следующему обзёрваблу, пока текущий не стрельнёт `onComplete()`. Такой подход гарантирует, что объединяемые источники выпустят свои элементы в гарантированном порядке. Однако, это хреново, когда речь идёт о бесконечном обзёрвабле. Юзать объединение (_concatenation_), когда нужен чёткий порядок.

- `Observable.concat()` - аналог `Observable.merge(`). Объеденит эмишены разных `Observable` и будет пулять их поочерёдно, переключаясь к следующему источнику только после того, как текущий вызовет `onComplete()`. В простом примере с двумя обзёрваблами, отрабатывает в принципе так же, как `Observable.merge()`, но мы уже вкурили, что в данном случае порядок гарантирован.
Автор пишет, что надо не тупить и не concat'ить бесконечные обзёрваблы, мол, **RxJava** будет ждать `onComplete()`, которого по понятной причине не произойдёт. На крайняк, ставить такой _infinite_ `Observable` вторым в цепочке, чтобы он запускался после первого. (можно вывернуться, кинув `take()`, и спровоцировать этим вызов `onComplete()`).

- `Observable.concatArray()` стригеррит выпуск каждого `Observable` в `Observable[]`. Обычный `Observable.concat()` также спокойно справляется с `Iterable<Observable<T>>` и эмитит их по-очереди.

- `concatMapEager()` подпишется на все полученные `Observable`, скэширует эмишены до тех пор, пока не придёт их черёд в очереди.

- `concatMap()` - по аналогии с уже существующим `flatMap()`'ом, который мёрджит обзёрваблы, полученные из каждого эмишена, есть оператор для объединения таких вещей - `concatMap()`. Он предпочтительнее в случае, когда нам важен порядок объединения элементов. Каждый обзёрвабл мапится из эмишна до тех пор, пока тот не завершится. Только потом стартует следующий эмишн. Если источник выпускает больше обзёрваблов, чем `concatMap()` может обработать за промежуток времени, они ставятся в очередь.

Предыдущие примеры `flatMap()`'а больше подходят для `concatMap()`'а, потому что в них важна очерёдность. И хотя результатом использования обоих операторов будет одно и то же, всё таки стоит правильно использовать каждый из них, чтобы потом не удивляться, почему порядок вдруг поплыл (прим.ред). Опять же, использовать `concatMap()` на бесконечных источниках тупо, потому что он работает через `onComplete()`. В таком случае надо брать `flatMap()`.

#### Ambiguous
После слияния(_merge_) и объединения(_concatenation_) надо бы пару слов сказать об _ambiguous_(хрен знает, яндекс.переводчик топит за "неоднозначный, двоякий").

 - `Observable.amb()` принимает `Iterable<Observable<T>>` и выпускает эмишены первого заэмитившего `Observable`. Остальные в свою очередь высвобождаются.
Первым считается такой обзёрвабл, чьи эмишены проходят через данное звено в чейне(толкование автора конспекта). Это полезно, когда у вас несколько источников одних и тех же данных, поэтому вам пофиг откуда их брать, лишь бы побыстрее.
    
#### Zipping
Зиппинг позволяет взять несколько разных эмишенов и объеденить их в один. Типы входных эмишенов могут быть разные, но мы можем объеденить и их тоже.

- Оператор `zip()` работает по принципу молнии: эмишн одного обзёрвабла ждёт эмишн другого, чтобы зазиповаться с ним. Если один обзёрвабл выпалил `onComplete()`, а у другого есть элементы к выпуску, они просто напросто дропнутся.
Можно с таким же успехом использовать `zipWith()`.

- В фабрику `Observable.zip()` вариант подать до девяти `Obsevable`'ов. Если надо больше, то использовать `zip.Array()`.

>Тут надо иметь в виду, что, если один из источников эмитит медленнее, чем остальные, другие источники данных будут тупить и ждать отстающего. Если пофиг на конкретный эмишн и надо взять последний, то можно использовать `combineLatest()`(о нём чуть позже). 
    
#### Combine latest
- `Observable.combineLatest()` - что-то похожее на `zip()`, только отрабатывает с самым последним элементом, выпущенным из любого другого источника. Он не блочит и не ставит в очередь эмишены, которым не нашлось пары, но кэширует их и зипует с последним. Проще говоря, когда один источник эмитит, результат зипуется с последним заэмиченным элементом другого источника. 
Крайне актуально, когда речь идёт о комбинировании **UI** _input_'ов, так как там не важны предыдущие инпуты пользователя, а нужен только последний.

- `withLatestFrom(`) - немного отличается от `combineLatest()`. Он мапит каждый `T` элемент одного эмишена с последним элементом другого, но берёт из каждых эмишенов только _ОДИН_ элемент. В итоге получится, что повторяющихся значений не будет.

#### Grouping
Возможность группировать разные эмишены в отдельные `Observable` - мощнейший инструмент **rxJava**. 

 - Для таких манёвров у неё есть оператор `groupBy()`, который принимает лямбду и маппит эмишн к соотв.ключу. Затем он возвращает `Observable<GroupedObservable<K,T>>`, который эмитит специальный тип `GroupedObservable`. Такой обзёрвабл почти ничем не отличается от обычного, только у него есть значение ключа в качестве свойства.
 
К примеру, у нас есть набор стрингов, которые мы хотим объединить по длине:
```java
Observable<String> source = Observable.just("Кот", "Пёс", "Змея","Либерал");
Observable<GroupedObservable<Integer,String>> byLengths =
source.groupBy(s -> s.lenght());
```
Скорее всего мы захотим использовать `flatMap()` к каждому элементу `GroupedObservable`, а внутри этого флэтмапа попробуем собрать результаты в кучу. В таком случае на выходе получится `Single`, поэтому и использовать надо `flatMapSingle()`. Давайте вызовем `toList()`, чтобы выпустить эмишены в виде листов с элементами, сгруппированными по длине:

```java
byLengths.flatMapSingle(grp -> grp.toList())
	.subscribe(System.out::prinln);
	
>output:
[Кот, Пёс]
[Змея]
[Либерал]
```

На выходе у нас получились списки с элементами одинаковой длины. (вообще, либерал, конечено, должен был запоковаться вместе с змеёй, но **RxJava** далека от политики и срабатывает чётко, как автомат Калашникова). 
У `GroupedObservable` есть метод `getKey()`, возвращающий ключ, с которым ассоциируется этот обзёрвабл.

-----

### Multicasting, Replaying, and Caching
В этой главе речь будет идти преимущественно о _multicasting_. _Replaying_ и _cashing_ - это на самом деле тоже про мультикаст. Будет и разбор `Subjects`, утилиты, предназначенной для _decoupling_ при мультикасте. Она должна быть использована с умом и в конкретных случаях. Также рассмотрим несколько вариаций _subjects_.

#### Раскуриваем мультикастинг(_multicasting_)
Ранее мы уже имели дело с `ConnectableObservable`, который эмитит элементы всем подписанным `Observer`'aм при вызове метода `connect()`. Такая идея объединения стримов называется мультикастом. 
Но есть некоторые ньюансы, когда речь заходит о применении операторов, которые могут опять создать отдельные стримы.

##### Мультикастинг с операторами
Тут соль в том, _КОГДА_ консолидируются стримы.
Например, если вызвать мультикастинг(с помощью `publish()`) до оператора `map()`, то стримы будут объеденены в один прокси `Observable` _до_ того, как будет применена мапа. 
 
![](multicast-before-map.png) 

Если мы хотим, чтобы оператор `map()` не генерил нам разные стримы для каждого `Observer`'а, то `publish()` надо вызывать _ПОСЛЕ_ `map()`.

![](multicast-after-map.png) 

##### Когда собственно нужен мультикаст
В целом эта фича полезна для того, чтобы избежать ненужного повторения одной и той же работы, а также в тех случаях, когда разные `Observer`'ы используют одни и те же данные. Плюс ко всему это позволяет разгрузить CPU.
Надо помнить, что мультикастинг создаёт горячий `ConnectableObservable`. Тут важно правильно вызвать `connect()`, чтобы ни один из подписчиков не проморгал данные.
Рекомендуется держать ваши обзёрваблы холодными и вызывать `publish()` только когда нужно, чтобы они стали погорячее.
Даже в случае с горячими обзерваблами (типа UI в андроиде), иногда не стоит лишний раз обвешивать их ненужными операторами. Это увеличивает стоимость операции, да и нафига, если у нас, к примеру, один только подписчик. Короче говоря: думать, прежде чем обмазывать всё `publish()`'ем. Вот если у нас несколько `Observer`'ов, то тут можно прикинуть, а не объединить ли их в один стрим.

#### Automatic connection
Вам стопудово когда-нибудь захочется вручную вызывать `connect()`, чтобы 
